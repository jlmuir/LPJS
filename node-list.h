#ifndef _NODE_LIST_H_
#define _NODE_LIST_H_

#ifndef _NODE_H_
#include "node.h"
#endif

#define LPJS_MAX_NODES  1024

typedef struct
{
    char        *head_node;
    unsigned    count;
    node_t      compute_nodes[LPJS_MAX_NODES];
}   node_list_t;

/* Return values for mutator functions */
#define NODE_LIST_DATA_OK              0
#define NODE_LIST_DATA_INVALID         -1      // Catch-all for non-specific error
#define NODE_LIST_DATA_OUT_OF_RANGE    -2
    
/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Accessor macros.  Use these to access structure members from functions
 *  outside the node_list_t class.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define NODE_LIST_HEAD_NODE(ptr)        ((ptr)->head_node)
#define NODE_LIST_HEAD_NODE_AE(ptr,c)   ((ptr)->head_node[c])
#define NODE_LIST_COUNT(ptr)            ((ptr)->count)
#define NODE_LIST_COMPUTE_NODES(ptr)    ((ptr)->compute_nodes)
#define NODE_LIST_COMPUTE_NODES_AE(ptr,c) ((ptr)->compute_nodes[c])

/*
 *  Generated by /usr/local/bin/auto-gen-get-set
 *
 *  Mutator macros for setting with no sanity checking.  Use these to
 *  set structure members frOom functions outside the node_list_t
 *  class.  These macros perform no data validation.  Hence, they achieve
 *  maximum performance where data are guaranteed correct by other means.
 *  Use the mutator functions (same name as the macro, but lower case)
 *  for more robust code with a small performance penalty.
 *
 *  These generated macros are not expected to be perfect.  Check and edit
 *  as needed before adding to your code.
 */

#define NODE_LIST_SET_HEAD_NODE(ptr,val)        ((ptr)->head_node = (val))
#define NODE_LIST_SET_HEAD_NODE_CPY(ptr,val,array_size) strlcpy((ptr)->head_node,val,array_size)
#define NODE_LIST_SET_HEAD_NODE_AE(ptr,c,val)   ((ptr)->head_node[c] = (val))
#define NODE_LIST_SET_COUNT(ptr,val)            ((ptr)->count = (val))
#define NODE_LIST_SET_COMPUTE_NODES_CPY(ptr,val,array_size) \
    for (size_t c = 0; c < (array_size); ++c) (ptr)->compute_nodes[c] = val[c];
#define NODE_LIST_SET_COMPUTE_NODES_AE(ptr,c,val) ((ptr)->compute_nodes[c] = (val))

/* node-list.c */
void    node_list_init(node_list_t *node_list);
int     node_list_add_compute(node_list_t *node_list, FILE *input_stream,
	const char *conf_file);
void    node_list_send_status(int msg_fd, node_list_t *node_list);

/* node-list-mutators.c */
int node_list_set_head_node(node_list_t *node_list_ptr, char *new_head_node);
int node_list_set_head_node_ae(node_list_t *node_list_ptr, size_t c, char new_head_node_element);
int node_list_set_head_node_cpy(node_list_t *node_list_ptr, char *new_head_node, size_t array_size);
int node_list_set_count(node_list_t *node_list_ptr, unsigned new_count);
int node_list_set_compute_nodes_ae(node_list_t *node_list_ptr, size_t c, node_t new_compute_nodes_element);
int node_list_set_compute_nodes_cpy(node_list_t *node_list_ptr, node_t new_compute_nodes[], size_t array_size);
void node_list_update_compute(node_list_t *node_list, node_t *node);

#endif  // _NODE_LIST_H_
